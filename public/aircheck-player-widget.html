<!--
  Aircheck Player Widget for Webflow
  
  This widget fetches track configuration from a backend API so tracks
  configured on desktop will also appear on mobile devices.
  
  To use: Copy everything below and paste into a Webflow Embed element.
-->

<style>
    .audio-player-widget {
        all: initial;
        display: block;
        font-family: 'Courier New', monospace;
    }
    
    .audio-player-widget *,
    .audio-player-widget *::before,
    .audio-player-widget *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }
    
    .audio-player-widget {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background: linear-gradient(135deg, #a8a8a8 0%, #8a8a8a 50%, #7a7a7a 100%);
        border-radius: 12px;
        box-shadow: 0 8px 16px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
        position: relative;
    }
    
    .audio-player-widget .load-button {
        position: absolute;
        top: 10px;
        right: 10px;
        background: linear-gradient(135deg, #6a8a6a 0%, #5a7a5a 100%);
        border: 1px solid #4a6a4a;
        color: #f5f1e8;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-family: 'Courier New', monospace;
        font-size: 11px;
        font-weight: bold;
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .audio-player-widget .load-button:hover {
        background: linear-gradient(135deg, #7a9a7a 0%, #6a8a6a 100%);
    }
    
    .audio-player-widget .waveform-container {
        background: linear-gradient(180deg, #5a5a5a 0%, #6a6a6a 100%);
        padding: 4px;
        border-radius: 8px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 1px 0 rgba(255,255,255,0.1);
        margin-bottom: 20px;
    }
    
    .audio-player-widget #waveform {
        width: 100%;
        display: block;
        border-radius: 4px;
    }
    
    .audio-player-widget .progress-container {
        margin-top: 12px;
    }
    
    .audio-player-widget .progress-bar {
        height: 12px;
        background: linear-gradient(180deg, #4a4a4a 0%, #5a5a5a 100%);
        border-radius: 6px;
        box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        cursor: pointer;
        position: relative;
        overflow: hidden;
    }
    
    .audio-player-widget .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #d4a574 0%, #7c9cbf 100%);
        box-shadow: 0 0 4px rgba(212, 165, 116, 0.5);
        transition: width 100ms;
    }
    
    .audio-player-widget .progress-handle {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 16px;
        height: 16px;
        background: linear-gradient(135deg, #f5f1e8 0%, #d4c5b0 100%);
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.5);
        border: 1px solid #8a8a8a;
        cursor: grab;
        transition: left 100ms;
    }
    
    .audio-player-widget .time-display {
        display: flex;
        justify-content: space-between;
        margin-top: 8px;
        padding: 0 4px;
        font-size: 12px;
        color: #d4c5b0;
        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    
    .audio-player-widget .status-text {
        text-align: center;
        margin-top: 8px;
        font-size: 12px;
        color: #d4c5b0;
        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        letter-spacing: 1px;
    }
    
    .audio-player-widget .controls {
        display: flex;
        justify-content: center;
        gap: 16px;
        margin: 20px 0;
    }
    
    .audio-player-widget .control-btn {
        width: 64px;
        height: 64px;
        border-radius: 6px;
        border: 1px solid;
        cursor: pointer;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #f5f1e8;
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 2px 4px rgba(0,0,0,0.3);
        transition: all 150ms;
    }
    
    .audio-player-widget .control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
    }
    
    .audio-player-widget .btn-play {
        background: linear-gradient(135deg, #7c9cbf 0%, #6a8aaf 100%);
        border-color: #4a6a8a;
    }
    
    .audio-player-widget .btn-stop {
        background: linear-gradient(135deg, #d4a574 0%, #c49564 100%);
        border-color: #a48554;
    }
    
    .audio-player-widget .btn-skip,
    .audio-player-widget .btn-mute {
        background: linear-gradient(135deg, #9a9a9a 0%, #8a8a8a 100%);
        border-color: #6a6a6a;
    }
    
    .audio-player-widget .volume-control {
        display: flex;
        align-items: center;
        gap: 12px;
        margin: 0 auto 20px;
        max-width: 400px;
    }
    
    .audio-player-widget .volume-icon {
        color: #d4c5b0;
        font-size: 20px;
    }
    
    .audio-player-widget .volume-bar {
        flex: 1;
        height: 8px;
        background: linear-gradient(180deg, #4a4a4a 0%, #5a5a5a 100%);
        border-radius: 4px;
        box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        cursor: pointer;
        position: relative;
    }
    
    .audio-player-widget .volume-fill {
        height: 100%;
        background: linear-gradient(90deg, #6a8a6a 0%, #7a9a7a 100%);
        border-radius: 4px;
        transition: width 100ms;
    }
    
    .audio-player-widget .volume-handle {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 12px;
        height: 12px;
        background: linear-gradient(135deg, #f5f1e8 0%, #d4c5b0 100%);
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        border: 1px solid #8a8a8a;
        cursor: grab;
        transition: left 100ms;
    }
    
    .audio-player-widget .volume-value {
        color: #d4c5b0;
        font-size: 12px;
        min-width: 30px;
        text-align: right;
    }
    
    .audio-player-widget .track-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
    }
    
    .audio-player-widget .track-btn {
        padding: 12px;
        background: linear-gradient(135deg, #b8b8b8 0%, #a8a8a8 100%);
        border: 2px solid transparent;
        border-radius: 6px;
        cursor: pointer;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        font-weight: bold;
        color: #3a3a3a;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.3);
        transition: all 150ms;
    }
    
    .audio-player-widget .track-btn:hover {
        background: linear-gradient(135deg, #c8c8c8 0%, #b8b8b8 100%);
    }
    
    .audio-player-widget .track-btn.active {
        border-color: #7c9cbf;
        box-shadow: 0 0 8px rgba(124, 156, 191, 0.5), inset 0 1px 0 rgba(255,255,255,0.3);
    }
    
    .audio-player-widget .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        z-index: 10000;
        align-items: center;
        justify-content: center;
    }
    
    .audio-player-widget .modal.show {
        display: flex;
    }
    
    .audio-player-widget .modal-content {
        background: linear-gradient(135deg, #a8a8a8 0%, #8a8a8a 50%, #7a7a7a 100%);
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
    }
    
    .audio-player-widget .modal-title {
        color: #f5f1e8;
        font-size: 18px;
        margin-bottom: 16px;
        text-align: center;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    .audio-player-widget .modal-input {
        width: 100%;
        padding: 8px 12px;
        margin-bottom: 16px;
        background: #ffffff;
        border: 1px solid #8a8a8a;
        border-radius: 4px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
    }
    
    .audio-player-widget .track-edit {
        background: rgba(245, 241, 232, 0.3);
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 12px;
    }
    
    .audio-player-widget .track-edit label {
        display: block;
        color: #f5f1e8;
        font-size: 11px;
        margin-bottom: 4px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    
    .audio-player-widget .track-edit input {
        width: 100%;
        padding: 6px 8px;
        margin-bottom: 8px;
        background: #ffffff;
        border: 1px solid #8a8a8a;
        border-radius: 4px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
    }
    
    .audio-player-widget .modal-buttons {
        display: flex;
        gap: 12px;
        margin-top: 16px;
    }
    
    .audio-player-widget .modal-btn {
        flex: 1;
        padding: 10px 16px;
        border: 1px solid;
        border-radius: 4px;
        cursor: pointer;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        font-weight: bold;
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .audio-player-widget .btn-save {
        background: linear-gradient(135deg, #7c9cbf 0%, #6a8aaf 100%);
        border-color: #4a6a8a;
        color: #f5f1e8;
    }
    
    .audio-player-widget .btn-cancel {
        background: linear-gradient(135deg, #9a9a9a 0%, #8a8a8a 100%);
        border-color: #6a6a6a;
        color: #3a3a3a;
    }
    
    .audio-player-widget .save-status {
        text-align: center;
        margin-top: 12px;
        font-size: 11px;
        color: #d4c5b0;
    }
    
    .audio-player-widget .save-status.success {
        color: #7a9a7a;
    }
    
    .audio-player-widget .save-status.error {
        color: #d4a574;
    }
</style>

<div class="audio-player-widget">
    <button class="load-button" onclick="AudioPlayerWidget.openAdminPanel()">EDIT</button>
    
    <div class="waveform-container">
        <canvas id="waveform" width="800" height="100"></canvas>
        
        <div class="progress-container" id="progressContainer" style="display:none;">
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
                <div class="progress-handle" id="progressHandle"></div>
            </div>
            <div class="time-display">
                <span id="currentTime">0:00</span>
                <span id="duration">0:00</span>
            </div>
        </div>
        
        <div class="status-text" id="statusText">SELECT TRACK</div>
    </div>
    
    <div class="controls">
        <button class="control-btn btn-play" id="playBtn" onclick="AudioPlayerWidget.togglePlayPause()" disabled>&#9654;</button>
        <button class="control-btn btn-stop" onclick="AudioPlayerWidget.stopPlayback()">&#9632;</button>
        <button class="control-btn btn-skip" onclick="AudioPlayerWidget.skipNext()">&#9197;</button>
        <button class="control-btn btn-mute" onclick="AudioPlayerWidget.toggleMute()">&#128266;</button>
    </div>
    
    <div class="volume-control">
        <span class="volume-icon">&#128266;</span>
        <div class="volume-bar" id="volumeBar">
            <div class="volume-fill" id="volumeFill" style="width: 100%;"></div>
            <div class="volume-handle" id="volumeHandle" style="left: calc(100% - 6px);"></div>
        </div>
        <span class="volume-value" id="volumeValue">100</span>
    </div>
    
    <div class="track-grid" id="trackGrid"></div>
</div>

<div class="audio-player-widget">
    <div class="modal" id="adminModal">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="passwordPanel">
                <h3 class="modal-title">Admin Access</h3>
                <input type="password" class="modal-input" id="passwordInput" placeholder="Enter password">
                <div class="modal-buttons">
                    <button class="modal-btn btn-save" onclick="AudioPlayerWidget.checkPassword()">SUBMIT</button>
                    <button class="modal-btn btn-cancel" onclick="AudioPlayerWidget.closeAdminPanel()">CANCEL</button>
                </div>
            </div>
            
            <div id="editorPanel" style="display:none;">
                <h3 class="modal-title">Edit Tracks</h3>
                <div id="trackEditor"></div>
                <div id="saveStatus" class="save-status"></div>
                <div class="modal-buttons">
                    <button class="modal-btn btn-save" onclick="AudioPlayerWidget.saveTracks()">SAVE</button>
                    <button class="modal-btn btn-cancel" onclick="AudioPlayerWidget.closeAdminPanel()">CANCEL</button>
                </div>
            </div>
        </div>
    </div>
</div>

<audio id="audioPlayer"></audio>

<script>
(function() {
    'use strict';
    
    // Backend API endpoint for track storage (cross-origin)
    const API_BASE = 'https://eclectic-caramel-34e317.netlify.app/.netlify/functions/aircheck-tracks';
    const ADMIN_PASSWORD = 'HOIBF###';
    const STORAGE_KEY = 'audioPlayerTracks';
    const DEFAULT_TRACKS = [
        { label: 'Track 1', url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3' },
        { label: 'Track 2', url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3' },
        { label: 'Track 3', url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3' },
        { label: 'Track 4', url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3' },
        { label: 'Track 5', url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3' },
        { label: 'Track 6', url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3' }
    ];
    
    let tracks = [];
    let currentTrackIndex = -1;
    let isPlaying = false;
    let audioContext = null;
    let analyser = null;
    let source = null;
    let animationId = null;
    let isDraggingProgress = false;
    let isDraggingVolume = false;
    
    const audio = document.getElementById('audioPlayer');
    const canvas = document.getElementById('waveform');
    const ctx = canvas.getContext('2d');
    const playBtn = document.getElementById('playBtn');
    const statusText = document.getElementById('statusText');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');
    const progressHandle = document.getElementById('progressHandle');
    const currentTimeEl = document.getElementById('currentTime');
    const durationEl = document.getElementById('duration');
    const volumeBar = document.getElementById('volumeBar');
    const volumeFill = document.getElementById('volumeFill');
    const volumeHandle = document.getElementById('volumeHandle');
    const volumeValue = document.getElementById('volumeValue');
    
    // Load tracks from localStorage (fallback/cache)
    function loadTracksFromLocalStorage() {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
            try {
                return JSON.parse(stored);
            } catch (e) {
                return DEFAULT_TRACKS;
            }
        }
        return DEFAULT_TRACKS;
    }
    
    // Fetch tracks from backend API
    async function fetchTracksFromBackend() {
        try {
            const response = await fetch(API_BASE, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.tracks && Array.isArray(data.tracks)) {
                    console.log('Loaded tracks from backend:', data.source);
                    // Cache in localStorage for offline fallback
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(data.tracks));
                    return data.tracks;
                }
            }
            throw new Error('Invalid response from backend');
        } catch (error) {
            console.error('Failed to fetch tracks from backend:', error);
            // Fall back to localStorage cache
            return loadTracksFromLocalStorage();
        }
    }
    
    // Save tracks to backend API
    async function saveTracksToBackend(tracksToSave) {
        const saveStatus = document.getElementById('saveStatus');
        saveStatus.textContent = 'Saving...';
        saveStatus.className = 'save-status';
        
        try {
            const response = await fetch(API_BASE, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Admin-Password': ADMIN_PASSWORD
                },
                body: JSON.stringify({ tracks: tracksToSave })
            });
            
            if (response.ok) {
                const data = await response.json();
                // Also update localStorage cache
                localStorage.setItem(STORAGE_KEY, JSON.stringify(tracksToSave));
                saveStatus.textContent = 'Saved to server! Changes will appear on all devices.';
                saveStatus.className = 'save-status success';
                return true;
            } else {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to save');
            }
        } catch (error) {
            console.error('Failed to save tracks to backend:', error);
            // Fall back to localStorage only
            localStorage.setItem(STORAGE_KEY, JSON.stringify(tracksToSave));
            saveStatus.textContent = 'Saved locally only (server unavailable)';
            saveStatus.className = 'save-status error';
            return false;
        }
    }
    
    function renderTracks() {
        const grid = document.getElementById('trackGrid');
        grid.innerHTML = '';
        tracks.forEach((track, index) => {
            const btn = document.createElement('button');
            btn.className = 'track-btn';
            btn.textContent = track.label;
            btn.onclick = () => loadTrack(index);
            if (index === currentTrackIndex) {
                btn.classList.add('active');
            }
            grid.appendChild(btn);
        });
    }
    
    function loadTrack(index) {
        currentTrackIndex = index;
        const track = tracks[index];
        audio.src = track.url;
        audio.crossOrigin = 'anonymous';
        audio.load();
        
        audio.onerror = function() {
            console.error('Audio loading error:', audio.error);
            statusText.textContent = 'ERROR LOADING AUDIO - CHECK URL';
            isPlaying = false;
            playBtn.textContent = '\u25B6';
        };
        
        audio.onloadeddata = function() {
            console.log('Audio loaded successfully');
        };
        
        audio.play().then(() => {
            isPlaying = true;
            playBtn.textContent = '\u23F8';
            playBtn.disabled = false;
            statusText.textContent = 'NOW PLAYING: ' + track.label.toUpperCase();
            progressContainer.style.display = 'block';
            initAudioContext();
        }).catch(err => {
            console.error('Play error:', err);
            statusText.textContent = 'CLICK PLAY TO START';
            isPlaying = false;
            playBtn.textContent = '\u25B6';
            playBtn.disabled = false;
        });
        
        renderTracks();
    }
    
    function initAudioContext() {
        if (!audioContext) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source = audioContext.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
            } catch (e) {
                console.warn('AudioContext not available:', e);
            }
        }
        drawVisualization();
    }
    
    function drawVisualization() {
        const width = canvas.width;
        const height = canvas.height;
        
        const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
        bgGradient.addColorStop(0, '#b8b8b8');
        bgGradient.addColorStop(0.5, '#9a9a9a');
        bgGradient.addColorStop(1, '#7a7a7a');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, width, height);
        
        ctx.globalAlpha = 0.1;
        for (let i = 0; i < height; i += 2) {
            ctx.fillStyle = i % 4 === 0 ? '#ffffff' : '#000000';
            ctx.fillRect(0, i, width, 1);
        }
        ctx.globalAlpha = 1.0;
        
        const shadowGradient = ctx.createLinearGradient(0, 0, 0, 20);
        shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
        shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = shadowGradient;
        ctx.fillRect(0, 0, width, 20);
        
        if (analyser && isPlaying) {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            const barWidth = (width / bufferLength) * 2.5;
            const centerY = height / 2;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * (height * 0.7);
                const x = i * barWidth;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(x + 2, centerY - barHeight / 2 + 2, barWidth - 4, barHeight);
                
                const barGradient = ctx.createLinearGradient(x, centerY - barHeight / 2, x, centerY + barHeight / 2);
                barGradient.addColorStop(0, '#d4a574');
                barGradient.addColorStop(0.5, '#7c9cbf');
                barGradient.addColorStop(1, '#d4a574');
                ctx.fillStyle = barGradient;
                ctx.fillRect(x, centerY - barHeight / 2, barWidth - 4, barHeight);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(x, centerY - barHeight / 2, barWidth - 4, 2);
            }
        } else {
            const barCount = 64;
            const barWidth = width / barCount;
            const centerY = height / 2;
            
            for (let i = 0; i < barCount; i++) {
                const barHeight = 8;
                const x = i * barWidth;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(x + 1, centerY - barHeight / 2 + 1, barWidth - 2, barHeight);
                
                ctx.fillStyle = '#7c9cbf';
                ctx.globalAlpha = 0.4;
                ctx.fillRect(x, centerY - barHeight / 2, barWidth - 2, barHeight);
                ctx.globalAlpha = 1.0;
            }
        }
        
        if (isPlaying) {
            animationId = requestAnimationFrame(drawVisualization);
        }
    }
    
    function togglePlayPause() {
        if (isPlaying) {
            audio.pause();
            isPlaying = false;
            playBtn.textContent = '\u25B6';
        } else {
            audio.play();
            isPlaying = true;
            playBtn.textContent = '\u23F8';
            drawVisualization();
        }
    }
    
    function stopPlayback() {
        audio.pause();
        audio.currentTime = 0;
        isPlaying = false;
        playBtn.textContent = '\u25B6';
        progressFill.style.width = '0%';
        progressHandle.style.left = '-8px';
    }
    
    function skipNext() {
        if (currentTrackIndex < tracks.length - 1) {
            loadTrack(currentTrackIndex + 1);
        }
    }
    
    function toggleMute() {
        audio.muted = !audio.muted;
    }
    
    function formatTime(seconds) {
        if (!seconds || isNaN(seconds)) return '0:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return mins + ':' + secs.toString().padStart(2, '0');
    }
    
    audio.addEventListener('timeupdate', () => {
        if (!isDraggingProgress && audio.duration) {
            const progress = (audio.currentTime / audio.duration) * 100;
            progressFill.style.width = progress + '%';
            progressHandle.style.left = 'calc(' + progress + '% - 8px)';
            currentTimeEl.textContent = formatTime(audio.currentTime);
            durationEl.textContent = formatTime(audio.duration);
        }
    });
    
    // Progress bar - mouse events
    progressBar.addEventListener('click', (e) => {
        if (!audio.duration) return;
        const rect = progressBar.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const percentage = (clickX / rect.width) * 100;
        audio.currentTime = (percentage / 100) * audio.duration;
    });
    
    progressBar.addEventListener('mousedown', (e) => {
        isDraggingProgress = true;
    });
    
    // Progress bar - touch events for mobile
    progressBar.addEventListener('touchstart', (e) => {
        isDraggingProgress = true;
        e.preventDefault();
    });
    
    progressBar.addEventListener('touchmove', (e) => {
        if (isDraggingProgress && audio.duration) {
            const rect = progressBar.getBoundingClientRect();
            const touch = e.touches[0];
            const moveX = touch.clientX - rect.left;
            const percentage = Math.max(0, Math.min(100, (moveX / rect.width) * 100));
            audio.currentTime = (percentage / 100) * audio.duration;
            e.preventDefault();
        }
    });
    
    progressBar.addEventListener('touchend', () => {
        isDraggingProgress = false;
    });
    
    document.addEventListener('mousemove', (e) => {
        if (isDraggingProgress && audio.duration) {
            const rect = progressBar.getBoundingClientRect();
            const moveX = e.clientX - rect.left;
            const percentage = Math.max(0, Math.min(100, (moveX / rect.width) * 100));
            audio.currentTime = (percentage / 100) * audio.duration;
        }
        if (isDraggingVolume) {
            const rect = volumeBar.getBoundingClientRect();
            const moveX = e.clientX - rect.left;
            const percentage = Math.max(0, Math.min(100, (moveX / rect.width) * 100));
            audio.volume = percentage / 100;
            volumeFill.style.width = percentage + '%';
            volumeHandle.style.left = 'calc(' + percentage + '% - 6px)';
            volumeValue.textContent = Math.round(percentage);
        }
    });
    
    document.addEventListener('mouseup', () => {
        isDraggingProgress = false;
        isDraggingVolume = false;
    });
    
    // Volume bar - mouse events
    volumeBar.addEventListener('click', (e) => {
        const rect = volumeBar.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const percentage = Math.max(0, Math.min(100, (clickX / rect.width) * 100));
        audio.volume = percentage / 100;
        volumeFill.style.width = percentage + '%';
        volumeHandle.style.left = 'calc(' + percentage + '% - 6px)';
        volumeValue.textContent = Math.round(percentage);
    });
    
    volumeBar.addEventListener('mousedown', () => {
        isDraggingVolume = true;
    });
    
    // Volume bar - touch events for mobile
    volumeBar.addEventListener('touchstart', (e) => {
        isDraggingVolume = true;
        e.preventDefault();
    });
    
    volumeBar.addEventListener('touchmove', (e) => {
        if (isDraggingVolume) {
            const rect = volumeBar.getBoundingClientRect();
            const touch = e.touches[0];
            const moveX = touch.clientX - rect.left;
            const percentage = Math.max(0, Math.min(100, (moveX / rect.width) * 100));
            audio.volume = percentage / 100;
            volumeFill.style.width = percentage + '%';
            volumeHandle.style.left = 'calc(' + percentage + '% - 6px)';
            volumeValue.textContent = Math.round(percentage);
            e.preventDefault();
        }
    });
    
    volumeBar.addEventListener('touchend', () => {
        isDraggingVolume = false;
    });
    
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        switch (e.code) {
            case 'Space':
                e.preventDefault();
                if (currentTrackIndex >= 0) togglePlayPause();
                break;
            case 'ArrowLeft':
                e.preventDefault();
                if (audio.duration) {
                    audio.currentTime = Math.max(0, audio.currentTime - 10);
                }
                break;
            case 'ArrowRight':
                e.preventDefault();
                if (audio.duration) {
                    audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
                }
                break;
        }
    });
    
    function openAdminPanel() {
        document.getElementById('adminModal').classList.add('show');
        document.getElementById('passwordInput').value = '';
        document.getElementById('passwordPanel').style.display = 'block';
        document.getElementById('editorPanel').style.display = 'none';
    }
    
    function closeAdminPanel() {
        document.getElementById('adminModal').classList.remove('show');
    }
    
    function checkPassword() {
        const password = document.getElementById('passwordInput').value;
        if (password === ADMIN_PASSWORD) {
            showEditor();
        } else {
            alert('Incorrect password');
        }
    }
    
    function showEditor() {
        document.getElementById('passwordPanel').style.display = 'none';
        document.getElementById('editorPanel').style.display = 'block';
        document.getElementById('saveStatus').textContent = '';
        
        const editor = document.getElementById('trackEditor');
        editor.innerHTML = '';
        tracks.forEach((track, index) => {
            const div = document.createElement('div');
            div.className = 'track-edit';
            div.innerHTML = 
                '<label>Track ' + (index + 1) + ' Label:</label>' +
                '<input type="text" value="' + track.label + '" data-index="' + index + '" data-field="label">' +
                '<label>Track ' + (index + 1) + ' URL:</label>' +
                '<input type="text" value="' + track.url + '" data-index="' + index + '" data-field="url">';
            editor.appendChild(div);
        });
    }
    
    async function saveTracks() {
        const inputs = document.querySelectorAll('#trackEditor input');
        inputs.forEach(input => {
            const index = parseInt(input.dataset.index);
            const field = input.dataset.field;
            tracks[index][field] = input.value;
        });
        
        // Save to backend (will also cache in localStorage)
        await saveTracksToBackend(tracks);
        
        renderTracks();
        
        // Close modal after a short delay to show success message
        setTimeout(() => {
            closeAdminPanel();
        }, 1500);
    }
    
    document.getElementById('adminModal').addEventListener('click', closeAdminPanel);
    
    window.AudioPlayerWidget = {
        openAdminPanel: openAdminPanel,
        closeAdminPanel: closeAdminPanel,
        checkPassword: checkPassword,
        saveTracks: saveTracks,
        togglePlayPause: togglePlayPause,
        stopPlayback: stopPlayback,
        skipNext: skipNext,
        toggleMute: toggleMute
    };
    
    // Check if tracks are different from defaults (have real content)
    function hasRealTracks(tracksToCheck) {
        if (!tracksToCheck || !Array.isArray(tracksToCheck)) return false;
        // Check if any track has a non-default URL (not SoundHelix)
        return tracksToCheck.some(track => 
            track.url && !track.url.includes('soundhelix.com')
        );
    }
    
    // Initialize - fetch tracks from backend, but migrate localStorage if it has real tracks
    async function initialize() {
        statusText.textContent = 'LOADING TRACKS...';
        
        // First, check localStorage for existing real tracks
        const localTracks = loadTracksFromLocalStorage();
        const localHasRealTracks = hasRealTracks(localTracks);
        
        // Fetch from backend
        let backendTracks = null;
        let backendHasRealTracks = false;
        try {
            const response = await fetch(API_BASE, {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' }
            });
            if (response.ok) {
                const data = await response.json();
                if (data.tracks && Array.isArray(data.tracks)) {
                    backendTracks = data.tracks;
                    backendHasRealTracks = hasRealTracks(backendTracks);
                    console.log('Backend tracks loaded, has real tracks:', backendHasRealTracks);
                }
            }
        } catch (error) {
            console.error('Failed to fetch from backend:', error);
        }
        
        // Decision logic:
        // 1. If localStorage has real tracks but backend doesn't, migrate localStorage to backend
        // 2. If backend has real tracks, use backend (it's the source of truth)
        // 3. Otherwise use whatever we have
        
        if (localHasRealTracks && !backendHasRealTracks) {
            console.log('Migrating localStorage tracks to backend...');
            tracks = localTracks;
            // Migrate to backend in background
            saveTracksToBackend(localTracks).then(success => {
                if (success) {
                    console.log('Successfully migrated localStorage tracks to backend');
                }
            });
        } else if (backendTracks) {
            tracks = backendTracks;
            // Update localStorage cache
            localStorage.setItem(STORAGE_KEY, JSON.stringify(backendTracks));
        } else {
            tracks = localTracks;
        }
        
        renderTracks();
        drawVisualization();
        statusText.textContent = 'SELECT TRACK';
    }
    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
})();
</script>
